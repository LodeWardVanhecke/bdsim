#ifndef myMatrixBoost_h
#define myMatrixBoost_h 1

#include "G4ios.hh" 
#include "globals.hh"
#include "Randomize.hh" 
#include "G4VDiscreteProcess.hh"
#include "G4Track.hh"
#include "G4Step.hh"
#include "G4Gamma.hh"
#include "G4Electron.hh"
#include "G4Positron.hh"
#include "G4OrderedTable.hh" 
#include "G4PhysicsTable.hh"
#include "G4PhysicsLogVector.hh"
#include "myComptonEngine.hh"
#include "myMaterials.hh"
#include "Randomize.hh"

#include "G4ChordFinder.hh"
#include "G4FieldManager.hh"
#include "G4MagIntegratorDriver.hh"
#include "G4MagIntegratorStepper.hh"
#include "G4FieldTrack.hh"

#include "G4StepStatus.hh"

extern myMaterials* BDSMaterials;
extern G4double BDSLocalRadiusOfCurvature;
 
class myMatrixBoost : public G4VDiscreteProcess 
{ 
public:
 
  myMatrixBoost(const G4String& processName = "mySynchRad");
 
  ~myMatrixBoost();

  G4bool IsApplicable(const G4ParticleDefinition&);
     
  G4double GetMeanFreePath(const G4Track& track,
			   G4double previousStepSize,
			   G4ForceCondition* condition );
 
  G4VParticleChange *PostStepDoIt(const G4Track& track,         
				  const G4Step&  step);                 

  G4double SynGenC(G4double xmin);
  G4double SynRadC(G4double x);

protected:

private:

  myMatrixBoost & operator=(const myMatrixBoost &right);
     
  myMatrixBoost(const myMatrixBoost&);

  G4double nExpConst;
  G4double CritEngFac;

private:
};

inline G4bool 
myMatrixBoost::IsApplicable(const G4ParticleDefinition& particle)
{
  return(  (&particle == G4Electron::Electron())
	   ||(&particle == G4Positron::Positron()) );
}

inline G4double 
myMatrixBoost::GetMeanFreePath(const G4Track& track,
			       G4double PreviousStepSize,
			       G4ForceCondition* ForceCondition)
{  
   *ForceCondition = Forced ;

    return DBL_MAX;

}
  


#endif
