// gab:
#include "BDSGlobalConstants.hh" // must be first in include list
#include "BDSSpoiler.hh"
#include "G4VisAttributes.hh"
#include "G4LogicalVolume.hh"
#include "G4VPhysicalVolume.hh"
#include "G4PVPlacement.hh"               
#include "G4UserLimits.hh"
#include "G4TransportationManager.hh"

#include "G4SDManager.hh"
//#include"MagFieldFunction.hh"
#include <map>

//============================================================
typedef std::map<G4String,int> LogVolCountMap;
extern LogVolCountMap* LogVolCount;

typedef std::map<G4String,G4LogicalVolume*> LogVolMap;
extern LogVolMap* LogVol;
extern myMaterials* BDSMaterials;
//============================================================

BDSSpoiler::BDSSpoiler (G4String& aName,G4double aLength,G4double bpRad,
                      G4double xAper,G4double yAper,
                      G4Material* SpoilerMaterial):
  itsSpoilerMaterial(SpoilerMaterial),
  myAcceleratorComponent(
			 aName,
			 aLength,bpRad,xAper,yAper,
			 SetVisAttributes())
{
  SpoilerLogicalVolume();
  
  if (   (*LogVolCount)[itsName]==1)
   {
 //   G4cout<<"xAper="<<xAper/mm<<"yaper="<<yAper/mm<<" bprad="<<itsBpRadius/mm
     // <<G4endl;


     // build beampipe
     // itsBeamPipe=new myBeamPipe(itsName,
     //				itsLength+BDSGlobals->GetLengthSafety(),
     //			itsBpRadius);

     // G4LogicalVolume* itsBeampipeLogical=itsBeamPipe->GetLogicalVolume();

     BuildInnerSpoiler();     

     //     itsSpoilerInBmp = 
     //  new G4PVPlacement(
     //		 0,			  // no rotation
     //		 0,                       // its position
     //		 itsInnerTubeLogVol,	  // its logical volume
     //		 itsName+"_spoilerInBmp", // its name
     //		 itsBeampipeLogical,      // its mother  volume
     //		 false,		          // no boolean operation
     //		 0);		          // copy number 

     itsPhysiComp = 
       new G4PVPlacement(
			 0,			  // no rotation
			 0,                       // its position
			 itsInnerBoxLogVol,	  // its logical volume
			 itsName+"_solid",	  // its name
			 itsMarkerLogicalVolume,   // its mother  volume
			 false,		          // no boolean operation
			 0);		          // copy number 
   }
}


void BDSSpoiler::SpoilerLogicalVolume()
{
  
  if(!(*LogVolCount)[itsName])
    {

      //      G4cout<<"itsLength="<<itsLength<<" lcbox="<<
      //	BDSGlobals->GetComponentBoxSize()/2<<G4endl;

      itsMarkerLogicalVolume=
	new G4LogicalVolume(
			    new G4Box(itsName,
				      BDSGlobals->GetComponentBoxSize()/2,
				      BDSGlobals->GetComponentBoxSize()/2,
				      itsLength/2),
			    BDSMaterials->LCVacuum,
			    itsName);

      (*LogVolCount)[itsName]=1;
      (*LogVol)[itsName]=itsMarkerLogicalVolume;
    }
  else
    {
      (*LogVolCount)[itsName]++;
      itsMarkerLogicalVolume=(*LogVol)[itsName];
     }
}

G4VisAttributes* BDSSpoiler::SetVisAttributes()
{
  itsVisAttributes=new G4VisAttributes(G4Colour(0,1,0));
  return itsVisAttributes;
}


void BDSSpoiler::BuildInnerSpoiler()
{
  //G4double maxAper=itsBpRadius-BDSGlobals->GetBeampipeThickness();

  /*
  itsInnerSpoilerTube=new G4Tubs(itsName+"_inner_spoiler_tube",
				 0,
				 maxAper,
				 itsLength/2,0,
				 twopi*radian);
  */

  G4double localXAper=itsXAper;
  G4double localYAper=itsYAper;

  //  if(itsXAper>maxAper)localXAper=maxAper;
  //  if(itsYAper>maxAper)localYAper=maxAper;

  itsInnerSpoilerBox=new G4Box(itsName+"_inner_spoiler_box",
                               localXAper,
                               localYAper,
                               itsLength/2);
 
  //  itsInnerBoxInTube= 
  //   new G4IntersectionSolid(itsName+"InnerBoxInTube",
  //		    itsInnerSpoilerBox,itsInnerSpoilerTube,0,0);

  //itsSpoilerTube=new G4Tubs(itsName+"_spoiler_tube",
  //				 0,
  //				 maxAper,
  //			 itsLength/2,0,
  //			 twopi*radian);

  //  itsInnerTubeLogVol=new G4LogicalVolume(itsSpoilerTube,
  //					 itsSpoilerMaterial,
  //				 itsName+"_InnerTube");
  itsInnerBoxLogVol=new G4LogicalVolume(itsInnerSpoilerBox,
					BDSMaterials->LCVacuum,
					itsName+"_InnerBoxInTube");

  /*
  G4VPhysicalVolume* itsInnerSpoiler = 
    new G4PVPlacement(
		      0,			// no rotation
		      0,	                // at (0,0,0)
		      itsInnerBoxLogVol,        // its logical volume
		      itsName+"_inner_spoiler", // its name
		      itsInnerTubeLogVol,       // its mother  volume
		      true,		        // no boolean operation
		      0);		        // copy number
  */
  SetSensitiveVolume(itsMarkerLogicalVolume);

  itsMarkerLogicalVolume->
    SetUserLimits(new G4UserLimits(DBL_MAX,DBL_MAX,DBL_MAX,
				   BDSGlobals->
				   GetThresholdCut()));
  // don't put cuts on the vacuum
  //  itsInnerBoxLogVol->SetUserLimits(new G4UserLimits(DBL_MAX,DBL_MAX,DBL_MAX,
  //					    BDSGlobals->
  //					    GetThresholdCut()));
}

BDSSpoiler::~BDSSpoiler()
{
  if(itsVisAttributes) delete itsVisAttributes;
  if(itsUserLimits) delete itsUserLimits;
  if(itsInnerSpoiler) delete itsInnerSpoiler;
  if(itsInnerBoxLogVol) delete itsInnerBoxLogVol;
  if(itsInnerTubeLogVol) delete itsInnerTubeLogVol;
  if(itsInnerBoxInTube) delete itsInnerBoxInTube;
  if(itsInnerSpoilerBox) delete itsInnerSpoilerBox;
  if(itsInnerSpoilerTube) delete itsInnerSpoilerTube;
  if(itsSpoilerInBmp) delete itsSpoilerInBmp;
  if(itsPhysiComp) delete itsPhysiComp;
}
