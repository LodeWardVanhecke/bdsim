<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BDS: include/myAcceleratorModel.hh Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>myAcceleratorModel.hh</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Merlin C++ Class Library for Charged Particle Accelerator Simulations</span>
00003 <span class="comment"> * </span>
00004 <span class="comment"> * Class library version 2.0 (1999)</span>
00005 <span class="comment"> * </span>
00006 <span class="comment"> * file Merlin\AcceleratorModel\AdvancedModel\AcceleratorModel.h</span>
00007 <span class="comment"> * last modified 11/07/00 21:35:17</span>
00008 <span class="comment"> */</span>
00009 
00010 <span class="comment">/*</span>
00011 <span class="comment"> * This file is derived from software bearing the following</span>
00012 <span class="comment"> * restrictions:</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * MERLIN C++ class library for </span>
00015 <span class="comment"> * Charge Particle Accelerator Simulations</span>
00016 <span class="comment"> * Copyright (c) 1999 by N.J.Walker.  ALL RIGHTS RESERVED. </span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * Permission to use, copy, modify, distribute and sell this</span>
00019 <span class="comment"> * software and its documentation for any purpose is hereby</span>
00020 <span class="comment"> * granted without fee, provided that the above copyright notice</span>
00021 <span class="comment"> * appear in all copies and that both that copyright notice and</span>
00022 <span class="comment"> * this permission notice appear in supporting documentation.</span>
00023 <span class="comment"> * No representations about the suitability of this software for</span>
00024 <span class="comment"> * any purpose is made. It is provided "as is" without express</span>
00025 <span class="comment"> * or implied warranty.</span>
00026 <span class="comment"> */</span>
00027 
00028 <span class="preprocessor">#ifndef myAcceleratorModel_h</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define myAcceleratorModel_h 1</span>
00030 <span class="preprocessor"></span>
00031 
00032 <span class="comment">//#include "merlin_config.h"</span>
00033 
00034 
00035 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00036 <span class="preprocessor">#include &lt;set&gt;</span>
00037 <span class="preprocessor">#include &lt;vector&gt;</span>
00038 <span class="preprocessor">#include &lt;string&gt;</span>
00039 
00040 <span class="comment">// StringPattern</span>
00041 <span class="preprocessor">#include "myStringPattern.hh"</span>
00042 
00043 <span class="comment">//class myModelElement;</span>
00044 <span class="comment">//class myComponentFrame;</span>
00045 
00046 <span class="keyword">class </span>myAcceleratorComponent;
00047 
00048 <span class="comment">// gab:</span>
00049 <span class="comment">//class SequenceFrame;</span>
00050 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>TmyAcceleratorComponent;
00051 
00052 <span class="keyword">using</span> std::string;
00053 <span class="keyword">using</span> std::set;
00054 <span class="keyword">using</span> std::vector;
00055 
00056 <span class="keyword">class </span>myAcceleratorModel 
00057 {
00058   <span class="keyword">private</span>:
00059     <span class="comment">//  Used to store and access all the ModelElement objects</span>
00060     <span class="comment">//  associated (contained) by an AcceleratorModel. Primary</span>
00061     <span class="comment">//  functions are fast keyed access to ModelElements, and</span>
00062     <span class="comment">//  memory management.</span>
00063 
00064     <span class="keyword">typedef</span> set&lt;myAcceleratorComponent*&gt; ElementRepository;
00065 
00066   <span class="keyword">public</span>:
00067     <span class="comment">//  A sequence of myAcceleratorComponent objects representing the</span>
00068     <span class="comment">//  complete accelerator lattice.</span>
00069 
00070         <span class="keyword">typedef</span> std::vector&lt;myAcceleratorComponent*&gt; FlatLattice;
00071 
00072     <span class="comment">//  Iterator definitions.</span>
00073      <span class="keyword">typedef</span> FlatLattice::iterator BeamlineIterator;
00074      <span class="keyword">typedef</span> FlatLattice::const_iterator ConstBeamlineIterator;
00075 
00076     <span class="comment">//  Represents the complete or  contiguous sub-section of</span>
00077     <span class="comment">//  the accelerator lattice.</span>
00078 
00079     <span class="keyword">class </span>Beamline 
00080     {
00081       <span class="keyword">protected</span>:
00082         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00083         <span class="keyword">class </span>TRK 
00084         {
00085           <span class="keyword">public</span>:
00086               <span class="keyword">explicit</span> TRK (T&amp; aT)
00087                 : _t(aT)
00088               { }
00089 
00090 
00091               <span class="keywordtype">void</span> operator () (myAcceleratorComponent* frame)
00092               {
00093                 _t(frame);
00094               }
00095 
00096             <span class="comment">// Data Members for Class Attributes</span>
00097 
00098               T&amp; _t;
00099 
00100           <span class="keyword">protected</span>:
00101           <span class="keyword">private</span>:
00102           <span class="keyword">private</span>:  
00103         };
00104 
00105       <span class="keyword">public</span>:
00106           Beamline (BeamlineIterator fst, BeamlineIterator lst)
00107                         : first(fst),last(lst)
00108           { }
00109 
00110           <span class="comment">//    Returns true if the beamline is reversed.</span>
00111           <span class="keywordtype">bool</span> IsReversed ()
00112           {
00113                           <span class="keywordflow">return</span> first&gt;last;
00114           }
00115 
00116           <span class="comment">//    Template function that iterates the functor object tobj</span>
00117           <span class="comment">//    over the Beamline. Returns a reference to tobj on exit.</span>
00118           <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; T&amp; Track (T&amp; tobj)
00119           {
00120                           <span class="comment">// We make use of the TRK wrapper, to avoid the call to tobj's</span>
00121                           <span class="comment">// copy constructor</span>
00122                           std::for_each(begin(),end(),TRK&lt;T&gt;(tobj));
00123                           <span class="keywordflow">return</span> tobj;
00124                           <span class="comment">// return std::for_each(begin(),end(),tobj);</span>
00125           }
00126           <span class="comment">//    Standard library type iterator accessors.</span>
00127           BeamlineIterator begin ()
00128           {
00129                           <span class="keywordflow">return</span> first;
00130           }
00131 
00132           ConstBeamlineIterator begin ()<span class="keyword"> const</span>
00133 <span class="keyword">          </span>{
00134                           <span class="keywordflow">return</span> first;
00135           }
00136 
00137           BeamlineIterator end ()
00138           {
00139                           <span class="keywordflow">return</span> last+1;
00140           }
00141 
00142           ConstBeamlineIterator end ()<span class="keyword"> const</span>
00143 <span class="keyword">          </span>{
00144                           <span class="keywordflow">return</span> last+1;
00145           }
00146 
00147           <span class="comment">//    Returns a reference to the first myComponentFrame.</span>
00148           myAcceleratorComponent&amp; First ()
00149           {
00150                           <span class="keywordflow">return</span> **first;
00151           }
00152 
00153           <span class="keyword">const</span> myAcceleratorComponent&amp; First ()<span class="keyword"> const</span>
00154 <span class="keyword">          </span>{
00155                           <span class="keywordflow">return</span> **first;
00156           }
00157 
00158           <span class="comment">//    Returns a reference to the last myComponentFrame.</span>
00159           myAcceleratorComponent&amp; Last ()
00160           {
00161                           <span class="keywordflow">return</span> **last;
00162           }
00163 
00164           <span class="keyword">const</span> myAcceleratorComponent&amp; Last ()<span class="keyword"> const</span>
00165 <span class="keyword">          </span>{
00166                           <span class="keywordflow">return</span> **last;
00167           }
00168 
00169       <span class="keyword">protected</span>:
00170       <span class="keyword">private</span>:
00171         <span class="comment">// Data Members for Class Attributes</span>
00172 
00173           BeamlineIterator first;
00174           BeamlineIterator last;
00175 
00176       <span class="keyword">private</span>:  
00177     };
00178 
00179     <span class="keyword">class </span>BadRange 
00180     {
00181       <span class="keyword">public</span>:
00182       <span class="keyword">protected</span>:
00183       <span class="keyword">private</span>:
00184       <span class="keyword">private</span>:  
00185     };
00186 
00187     <span class="keyword">typedef</span> size_t Index;
00188 
00189   <span class="keyword">public</span>:
00190       <span class="comment">//        Constructor.</span>
00191       myAcceleratorModel ();
00192 
00193       ~myAcceleratorModel ();
00194 
00195 
00196       <span class="comment">//        Returns the entire beamline of the model.</span>
00197       myAcceleratorModel::Beamline GetBeamline ();
00198 
00199       <span class="comment">//        Returns the beamline from elements n1 to n2.</span>
00200       myAcceleratorModel::Beamline GetBeamline (Index n1, Index n2) <span class="keywordflow">throw</span> (BadRange);
00201 
00202       <span class="comment">//        Returns a Beamline from the n1-th occurrence of the</span>
00203       <span class="comment">//        component whose qualified name  matches the pattern</span>
00204       <span class="comment">//        pat1, to the n2-th occurrence of the component matching</span>
00205       <span class="comment">//        patl2. Throws BadRange if no section is found.</span>
00206       myAcceleratorModel::Beamline GetBeamline (<span class="keyword">const</span> string&amp; pat1, <span class="keyword">const</span> string&amp; pat2, <span class="keywordtype">int</span> n1 = 1, <span class="keywordtype">int</span> n2 = 1) <span class="keywordflow">throw</span> (BadRange);
00207 
00208       <span class="comment">//        Returns the reversed complete beamline of the model.</span>
00209       myAcceleratorModel::Beamline GetReversedBeamline ();
00210 
00211       <span class="comment">//        Returns in results all myComponentFrame objects whose name</span>
00212       <span class="comment">//        matches the string pattern pat. Returns the length of</span>
00213       <span class="comment">//        results on exit. Note that the previous contents of</span>
00214       <span class="comment">//        results is overwritten. Components are returned in</span>
00215       <span class="comment">//        Beamline order.</span>
00216       <span class="keywordtype">int</span> ExtractComponents (<span class="keyword">const</span> string&amp; pat, vector&lt;myAcceleratorComponent*&gt;&amp; results);
00217 
00218       <span class="comment">//        Returns in results all myModelElement objects whose name</span>
00219       <span class="comment">//        matches the string pattern pat. Returns the length of</span>
00220       <span class="comment">//        results on exit. Note that the previous contents of</span>
00221       <span class="comment">//        results is overwritten. The order results is undefined.</span>
00222       <span class="keywordtype">int</span> ExtractmyModelElements (<span class="keyword">const</span> string&amp; pat, vector&lt;myAcceleratorComponent*&gt;&amp; results);
00223 
00224       <span class="comment">//        template function returning TmyComponentFrame objects</span>
00225       <span class="comment">//        corresponding to AcceleratorComponents of type T.</span>
00226       <span class="comment">//        pattern is optional string pattern which can be used to</span>
00227       <span class="comment">//        match only those components with a specific</span>
00228       <span class="comment">//        (unqualified) name. Components are returned in Beamline</span>
00229       <span class="comment">//        order.</span>
00230       <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">int</span> ExtractTypedComponents (vector&lt;TmyAcceleratorComponent&lt;T&gt;*&gt;&amp; results, <span class="keyword">const</span> string&amp; pattern = <span class="stringliteral">"*"</span>)
00231       {
00232 
00233                   vector&lt;TmyAcceleratorComponent&lt;T&gt;*&gt; temp;
00234                   myStringPattern p(pattern);
00235                   temp.reserve(10);
00236                   <span class="keywordflow">for</span>(BeamlineIterator i = lattice.begin(); i!=lattice.end(); i++) {
00237                         TmyAcceleratorComponent&lt;T&gt;* cf = dynamic_cast&lt;TmyAcceleratorComponent&lt;T&gt;*&gt;(*i);
00238                         <span class="keywordflow">if</span>(cf &amp;&amp; p(cf-&gt;GetName()))
00239                                 temp.push_back(cf);
00240                   }
00241                   results.swap(temp);
00242                   <span class="keywordflow">return</span> results.size();
00243       }
00244 
00245   <span class="comment">/* gab: &gt;&gt;&gt;</span>
00246 <span class="comment">      //        template function returning myModelElements of type T.</span>
00247 <span class="comment">      //        pattern is optional string pattern which can be used to</span>
00248 <span class="comment">      //        match only those components with a specific</span>
00249 <span class="comment">      //        (unqualified) name. Order is undefined.</span>
00250 <span class="comment">      template&lt;class T&gt; int ExtractTypedElements (T&amp; results, const string&amp; pattern = "*")</span>
00251 <span class="comment">      {</span>
00252 <span class="comment">                  T temp;</span>
00253 <span class="comment">                  myStringPattern p(pattern);</span>
00254 <span class="comment">                  for(ElementRepository::iterator i = elements.begin(); i!=elements.end(); i++) {</span>
00255 <span class="comment">                          T::value_type mi = dynamic_cast&lt;T::value_type&gt;(*i);</span>
00256 <span class="comment">                        if(mi &amp;&amp; p(mi-&gt;GetName()))</span>
00257 <span class="comment">                                temp.push_back(mi);</span>
00258 <span class="comment">                  }</span>
00259 <span class="comment">                  results.swap(temp);</span>
00260 <span class="comment">                  return results.size();</span>
00261 <span class="comment">      }</span>
00262 <span class="comment"></span>
00263 <span class="comment">      gab: &lt;&lt;&lt;*/</span>
00264 
00265   <span class="keyword">protected</span>:
00266   <span class="keyword">private</span>:
00267     <span class="comment">// Data Members for Associations</span>
00268 
00269       <span class="comment">//        The root object in the nested frame hierachy. Note that</span>
00270       <span class="comment">//        this myModelElement is not stored in the repository.</span>
00271   <span class="comment">// gab:</span>
00272   <span class="comment">//      SequenceFrame* globalFrame;</span>
00273       FlatLattice lattice;
00274 
00275       ElementRepository elements;
00276 
00277   <span class="keyword">private</span>:  
00278   <span class="comment">//    friend class myAcceleratorModelConstructor;</span>
00279 };
00280 
00281 
00282 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 1 13:36:40 2004 for BDS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
