/*
   bison grammar for the GMAD parser 
*/


%{
#include "sym_table.h"
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <list>

using namespace std;

 void help();
 void quit();

 double pow(double x, double y) {return exp( y * log(x));}
 
 int yyerror(char *);
 //extern  void yyerror (YYLTYPE *locp, char const *msg); 

 extern FILE* yyin;
 extern int yylex();
 int yyparse();

 int add_var(char *name,double value);
 int add_func(char *name, double (*func)(double));



 // structure

#define _NONE -1
#define _SBEND 0  
#define _QUAD  1
#define _MULT  2
#define _LINE 10

#define MAX_EXPAND_ITERATIONS 50
#define MAX_MULTIPOLE_ORDER 5

 list<double> _tmparray;

 struct Array {
   double *data;
   int size;
 };
 
 list<struct Array *> array_list;

 const char *typestr(int type) {
   switch(type){
   case _SBEND : 
     return "sbend";
     break;
   case _QUAD :
     return "quadrupole";
     break;
   case _MULT :
     return "multipole";
     break;
   case _LINE :
     return "line";
     break;
   default:
     return "none";
     break;
   }
 }

 struct Parameters {
   double l;  int lset;    // length
   double k0; int k0set;   // dipole 
   double k1; int k1set;   // quadrupole
   double k2; int k2set;   // sextupole
   double k3; int k3set;   // octupole

   list<double> knl;           // multipole expansion coefficients
   list<double> ksl;           // skew multipole expansion

   int knlset; int kslset;
   
   void flush() {
     l=0; lset = 0;
     k0 = 0; k0set = 0;
     k1 = 0; k1set = 0;
     k2 = 0; k2set = 0;
     k3 = 0; k3set = 0;

     knlset = 0; kslset=0;
     knl.erase(knl.begin(),knl.end());
     ksl.erase(ksl.begin(),ksl.end());
     
   }
 } params;
 
 struct Element {
   short type;
   char * name;
   
   double l,k0,k1,k2,k3;

   list<double> knl;
   list<double> ksl;
    
   // in case the element is a list itself (line)
   list <struct Element> *lst;

 } element;

 void flush(struct Element& e )
   {
     e.l = 0;
     e.k0 = 0;
     e.k1 = 0;
     e.k2 = 0;
     e.name = NULL;
     e.type = _NONE;
   }

 void copy_properties(list<struct Element>::iterator dest, list<struct Element>::iterator src)
   {
     (*dest).type = (*src).type; 
     (*dest).l = (*src).l;
     (*dest).k0 = (*src).k0; 
     (*dest).k1 = (*src).k1; 
     (*dest).k2 = (*src).k2; 
     (*dest).k3 = (*src).k3; 
     (*dest).knl = (*src).knl;
     (*dest).ksl = (*src).ksl;
   }  

 void inherit_properties(struct Element e)
   {
     // copy parameters into temporary buffer params from element e
     // parameters already set in params have priority and are not overridden

     if(!params.lset) params.l = e.l;
     if(!params.k0set) params.k0 = e.k0;
     if(!params.k1set) params.k1 = e.k1;
     if(!params.k2set) params.k2 = e.k2;
     if(!params.k3set) params.k3 = e.k3;

   }

 void set_vector(list<double> dst, struct Array *src)
   {
     for(int i=0; i< src->size;i++)
       dst.push_back(src->data[i]);
   }
 
 list<struct Element> element_list;
 list<struct Element> tmp_list;
 list<struct Element> beamline_list;

 char* current_line = "";

 int write_table(struct Parameters prm,char* name,int type, list<struct Element> *lst=NULL);
 int expand_line(char *name);
 list<struct Element>::iterator element_lookup(char *name);
 void print(list<struct Element>, int ident = 0);

 struct symtab symtab[NSYMS];

 extern struct symtab * symlook(char *s);

 // data types

 
%}


%union{
  double dval;
  int ival;
  struct symtab *symp;
  char *str;
  struct Array *array;
}


%left '+' '-'
%left '*' '/'
%left '^'
%nonassoc UMINUS

%token <dval> NUMBER
%token <symp> VARIABLE FUNC PERIOD
%token <str> STR
%token DIPOLE SBEND QUADRUPOLE SEXTUPOLE OCTUPOLE MULTIPOLE LINE SEQUENCE
%token OPTION PRINT RANGE STOP USE

%type <dval> aexpr
%type <dval> expr
%type <symp> assignment
%type <array> vecexpr;
%type <array> vector;
%type <str> use_parameters;
%type <ival> extension;
%%

input :               
     | input stmt ';' { printf("\n"); }
     ;

stmt : expr             //{ printf ("\t%.10g\n", $1); }
     | command 
     | decl
     ;

decl : 
     | VARIABLE ':' sbend
       {
	 printf("VARIABLE : sbend\n");
	 // check parameters and write into element table
	 write_table(params,$1->name,_SBEND);
	 params.flush();
       }
     | VARIABLE ':' quad
       {
	 printf("VARIABLE : quad %s \n",$1->name);
	 // check parameters and write into element table
	 write_table(params,$1->name,_QUAD);
	 params.flush();
       }
     | VARIABLE ':' sextupole
     | VARIABLE ':' octupole
     | VARIABLE ':' multipole
       {	 
	 printf("VARIABLE : multipole %s \n",$1->name);
	 // check parameters and write into element table
	 write_table(params,$1->name,_MULT);
	 params.flush();	 
       }
     | VARIABLE ':' line 
      {
	// create entry in the main table and add pointer to the parsed sequence
	printf("VARIABLE : LINE %s\n",$1->name);
	write_table(params,$1->name,_LINE,new list<struct Element>(tmp_list));
	tmp_list.erase(tmp_list.begin(), tmp_list.end());
      }
     | VARIABLE ':' sequence
     | VARIABLE ':' extension
       {
	 printf("VARIABLE : VARIABLE, %s  :  %s\n",$1->name, typestr($3));
	 if($3 != _NONE)
	   write_table(params,$1->name,$3);
	 params.flush();
       }
;

sbend : SBEND parameters
;

quad : QUADRUPOLE parameters
       {
	 printf("QUADRUPOLE parameters\n");
       }
;

sextupole : SEXTUPOLE parameters
;

octupole : OCTUPOLE parameters
;

multipole : MULTIPOLE parameters
;

extension : VARIABLE parameters
          {	 
	    printf("extension : VARIABLE parameters   -- %s \n",$1->name);
	    list<struct Element>::iterator it = element_lookup($1->name);
	    if(it == NULL)
	      {
		printf("type %s has not been defined\n",$1->name);
		$$ = _NONE;
	      }
	    else
	      {
		// inherit properties from the base type
		$$ = (*it).type;
		inherit_properties(*it);
	      }
	    
           }
;

parameters: 
          | parameters ',' VARIABLE '=' aexpr
            {
	      printf("parameters, VARIABLE(%s) = aexpr(%.10g)\n",$3->name,$5);
	      if(!strcmp($3->name,"l")) { params.l = $5; params.lset = 1;} 
	        else
	      if(!strcmp($3->name,"k0")) { params.k0 = $5; params.k0set = 1;}
		else 
	      if(!strcmp($3->name,"k1")) { params.k1 = $5; params.k1set = 1;} 
	        else
	      if(!strcmp($3->name,"k2")) { params.k2 = $5; params.k2set = 1;}
		else 	  
	      printf("unknown parameter %s\n",$3->name);
            }
          | parameters ',' VARIABLE '=' vecexpr 
            {
	      if(!strcmp($3->name,"knl")) 
		{
		  params.knlset = 1;
		  set_vector(params.knl,$5);
		  delete[] $5->data;
		} 
	        else
	      if(!strcmp($3->name,"ksl")) 
		{
		  params.kslset = 1;
		  set_vector(params.ksl,$5);
		  delete[] $5->data;
		}
	        else 	  
	      printf("unknown parameter %s\n",$3->name);
	    }         
          | VARIABLE '=' vecexpr 
            {
	      if(!strcmp($1->name,"knl")) 
		{
		  params.knlset = 1;
		  set_vector(params.knl,$3);
		  delete[] $3->data;
		} 
	        else
	      if(!strcmp($1->name,"ksl")) 
		{
		  params.kslset = 1;
		  set_vector(params.ksl,$3);
		  delete[] $3->data;
		}
	        else 	  
	      printf("unknown parameter %s\n",$1->name);
	    }         
          | VARIABLE '=' aexpr
            {
	      printf("VARIABLE = aexpr(%.10g)\n",$3);
            }

line : LINE '=' '(' element_seq ')'           
;

sequence : SEQUENCE;


element_seq : 
            | element_seq ',' VARIABLE 
              {
		printf("matched sequence element, %s\n",$3->name);
		// add to temporary element sequence
		{
		  struct Element e;
		  e.name = $3->name;
		  e.type = _LINE;
		  e.lst = NULL;
		  tmp_list.push_back(e);
		}
              }
            | VARIABLE
              {
		printf("matched last sequence element, %s\n",$1->name);
		// add to temporary element sequence
         	{
		  struct Element e;
		  e.name = $1->name;
		  e.type = _LINE;
		  e.lst = NULL;
		  tmp_list.push_back(e);
		}
              }
;


expr : aexpr 
       { // check type ??
	 printf ("\t%.10g\n", $1); $$=$1;
       }
     | vecexpr 
       {
 
	 for(int i=0;i<$1->size;i++)
	   {
	     printf(" %.10g ",$1->data[i]);
	   }
	 $$ = 0; 
       }
     | assignment 
       { // check type
	 if($1->type == _ARRAY)
	   {
	     for(list<double>::iterator it = $1->array.begin();
		 it!=$1->array.end();it++)
	       printf ("\t%.10g", (*it));
	     printf("\n");
	   }
	 else
	   printf ("\t%.10g\n", $1->value); 
	 $$=0;
       }
;

aexpr :  NUMBER               { $$ = $1;                         }
       | VARIABLE             
         { 
	   //check type ??
	   $$ = $1->value;        
          } 
       | FUNC '(' aexpr ')'   { $$ = (*($1->funcptr))($3);       } 
       | aexpr '+' aexpr      { $$ = $1 + $3;                    }
       | aexpr '-' aexpr      { $$ = $1 - $3;                    }  
       | aexpr '*' aexpr      { $$ = $1 * $3;                    }
       | aexpr '/' aexpr      { $$ = $1 / $3;                    }
       | aexpr '^' aexpr      { $$ = pow($1,$3);                 }
       | '-' aexpr  %prec UMINUS { $$ = -$2; }
       | '(' aexpr ')'         { $$ = $2;                         }
;

assignment :  VARIABLE '=' aexpr  { $1->value = $3; $$=$1;       }
           |  VARIABLE '=' vecexpr
              {
		$1->array.erase($1->array.begin(),$1->array.end());
		for(int i=0;i<$3->size;i++)
		  $1->array.push_back($3->data[i]);
		$1->type = _ARRAY;
		$$ = $1;
		delete[] $3->data;
		$3->size = 0;
              }
;

vecexpr : '{' VARIABLE '}'
        {
	  if($2->type ==_ARRAY)
	    {
	      $$ = new struct Array;
	      $$->data = new double[$2->array.size()];
	      $$->size = $2->array.size();
	      //array_list.push_back($$);
	      list<double>::iterator it = 0;
	      int i = 0;
	      for(it=$2->array.begin();it!=$2->array.end();it++)
		{
		  $$->data[i++] = (*it);
		}
	    }
        } 
        | vector
        {
	  $$ = new struct Array;
	  $$->data = new double[$1->size];
	  $$->size = $1->size;
	  //array_list.push_back($$);
	  int i = 0;
	  for(int i=0;i<$1->size;i++)
	    {
	      $$->data[i] = $1->data[i];
	    }
	  
	  //printf("vecexpr : vector   %d\n",$1->size);
	  
	  // erase data in vector
	  
	  delete[] $1->data;
	  $1->size = 0;
	  
	}
      | vector '+' vector
        {
	  $$ = new struct Array;
	  $$->size = ($1->size < $3->size )? $1->size : $3->size;
	  $$->data = new double[$$->size];
	  //array_list.push_back($$);
	  int i = 0;
	  for(int i=0;i<$$->size;i++)
	    {
	      $$->data[i] = $1->data[i] + $3->data[i];
	    }
	  
	  //printf("vecexpr : vector   %d\n",$1->size);
	  
	  // erase data in vector
	  
	  delete[] $1->data;
	  $1->size = 0;
        }
      | vector '-' vector
        {
	  $$ = new struct Array;
	  $$->size = ($1->size < $3->size )? $1->size : $3->size;
	  $$->data = new double[$$->size];
	  //array_list.push_back($$);
	  int i = 0;
	  for(int i=0;i<$$->size;i++)
	    {
	      $$->data[i] = $1->data[i] - $3->data[i];
	    }
	  
	  //printf("vecexpr : vector   %d\n",$1->size);
	  
	  // erase data in vector
	  
	  delete[] $1->data;
	  $1->size = 0;
        }

;

vector : '{' numbers '}' 
{
  //printf("matched vector of size %d\n",_tmparray.size());
  $$ = new struct Array;
  $$->data = new double[_tmparray.size()];
  $$->size = _tmparray.size();

  //array_list.push_back(a);

  list<double>::iterator it;
 
  int i=0;
  for(it=_tmparray.begin();it!=_tmparray.end();it++)
    {
      $$->data[i++] = (*it);
    }

  _tmparray.erase(_tmparray.begin(),_tmparray.end());
}
;

numbers : 
        | numbers ',' aexpr
          {
	    _tmparray.push_back($3);
          } 
       | aexpr
         {
	   _tmparray.push_back($1);
        }
;

command : STOP             { quit(); }
        | PRINT            { print( element_list ); }
        | PRINT ',' LINE   { print( beamline_list); } 
        | USE ',' use_parameters {current_line = $3; expand_line(current_line);}
        | OPTION  option_parameters
;

use_parameters :  PERIOD '=' VARIABLE
                  {
		    $$ = $3->name;
                  }
               | PERIOD '=' VARIABLE ',' RANGE '=' NUMBER
                  {
                    $$ = $3->name
                  }
;

option_parameters : 
                  | option_parameters ',' VARIABLE '=' NUMBER
;

%%



int yyerror(char *s)
{
  printf(s);
}

int main(int argc, char* argv[])
{
    // embedded arithmetical functions
    add_func("sqrt",sqrt);
    add_func("cos",cos);
    add_func("sin",sin);
    add_func("exp",exp);
    add_func("log",log); 
    
    params.flush();
    
    //start interactive mode

    printf(">>");
    
    yyin=stdin; 
    while(!feof(yyin))
      {
        yyparse();
      }


    return 0;
};

int yywrap()
{
	return 1;
}


// *********************
// functions
// *********************


void help()
{
  printf("helping...\n");
}

void quit()
{
  printf("parsing complete...\n");
  exit(0);
}

int write_table(struct Parameters params,char* name, int type, list<struct Element> *lst)
{
  printf("k1=%.10g ,k2=%.10g, type=%d\n",params.k1, params.k2, type);

  struct Element e;
  flush(e);
  e.name = name;

  switch(type) {
  case _QUAD:

    e.type = _QUAD;
    e.lst = NULL;
      
    if(params.lset) {
      e.l = params.l;
    }
    if(params.k0set) {
      printf("Warning: k2 will not be set for element %s of type QUADRUPOLE\n",name);
    }
    if(params.k1set) {
      e.k1 = params.k1;
    }
    if(params.k2set) {
      printf("Warning: k2 will not be set for element %s of type QUADRUPOLE\n",name);
    }
    
    break;
  case _SBEND:
    
    e.type = _SBEND;
    e.lst = NULL;
    
    if(params.lset) {
      e.l = params.l;
    }
    if(params.k1set) {
      printf("Warning: k1 will not be set for element %s of type SBEND\n",name);
    }
    if(params.k0set) {
      e.k0 = params.k0;
    }
    if(params.k2set) {
      printf("Warning: k2 will not be set for element %s of type SBEND\n",name);
    }
    
    break;

  case _MULT:
    
    e.type = _MULT;
    e.lst = NULL;
    
    if(params.knlset)
      e.knl = params.knl;

    if(params.kslset)
      e.ksl = params.ksl;

    if(params.lset) {
      e.l = params.l;
    }
    if(params.k1set) {
      printf("Warning: k1 will not be set for element %s of type MULTIPOLE\n",name);
    }
    if(params.k0set) {
      printf("Warning: k0 will not be set for element %s of type MULTIPOLE\n",name);
    }
    if(params.k2set) {
      printf("Warning: k2 will not be set for element %s of type MULTIPOLE\n",name);
    }
    
    break;

  case _LINE:
   
    e.lst = lst;
    e.type = _LINE;
    break;
    
  default:
    break;  
  }

  element_list.push_back(e);
}

int expand_line(char *name)
{
  list<struct Element>::iterator it;

  struct Element e;
  
  it = element_lookup(name);
  
  if( (it!=NULL) && ((*it).type == _LINE) ) 
    {
      // expand the desired beamline
      
      e.type = _LINE;
      e.name = name;
      e.lst = NULL;
      
      beamline_list.push_back(e);
      
      printf("preparing to expand %s\n",name);

      if(!(*it).lst) return 0; //list empty

      // copy the list into the resulting list
      beamline_list.insert(beamline_list.end(),((*it).lst)->begin(),((*it).lst)->end());

      bool is_expanded = false;

      // parse starting from the second element until the list is expanded
      int iteration = 0;
      while(!is_expanded)
	{
	  is_expanded = true;
	  for(it = ++beamline_list.begin();it!=beamline_list.end();it++ )
	    {
	      printf("saw  %s\n",(*it).name);
	      
	      if((*it).type == _LINE)  // list - expand further	  
		{
		  is_expanded = false;
		  // lookup the line in main list
		  list<struct Element>::iterator tmpit = element_lookup((*it).name);
		  
		  printf("%s is of type _LINE \n",(*it).name);
		  
		  if( (tmpit != NULL) && ( (*tmpit).lst != NULL) ) { // sublist found and not empty
		    beamline_list.insert(it,(*tmpit).lst->begin(),(*tmpit).lst->end());
		    // delete the list pointer
		    beamline_list.erase(it--);
		    printf("inserting sequence for %s\n",(*it).name);
		  } else if ( tmpit != NULL ) // entry points to a scalar element type -
		    //transfer properties from the main list
		    {
		      copy_properties(it,tmpit);
		    } else  // element of undefined type - neglecting
		      {
			printf("WARNING : Expanding line %s : \n element %s has not been defined , skipping \n",name,(*it).name);
			beamline_list.erase(it--);
		      }
		  
		} else  // element - keep as it is 
		  {
		    // do nothing
		    printf("Element %s is of type %s \n",(*it).name,typestr((*it).type) );
		  }
	      
	    }
	  iteration++;
	  if( iteration > MAX_EXPAND_ITERATIONS )
	    {
	      printf("Error : Line expansion of '%s' seems to loop, \
                     \n possible recursive line definition,quitting \n",name);
	      exit(0);
	    }
			      
	}// while
      
      return 0;
    }
  
  
  printf("line '%s' not found",name);
  
}

list<struct Element>::iterator element_lookup(char *name)
{
   list<struct Element>::iterator it;

   for(it=element_list.begin();it!=element_list.end();it++)
     {
       if(!strcmp((*it).name,name) )
	 return it;
     }
   return NULL;
}

void print(list<struct Element> l, int ident)
{

  if(ident == 0) printf("using line %s\n",current_line);

  list<struct Element>::iterator it;

  for(it=l.begin();it!=l.end();it++)
    {
      for(int i=0;i<ident;i++)
	printf("--");

      printf("->%s : %s",(*it).name,typestr((*it).type));

      switch((*it).type) {
      case _SBEND :
      case _QUAD:
	printf(", l=%.10g, k0=%.10g, k1=%.10g, k2=%.10g ",
	       (*it).l,(*it).k0,(*it).k1,(*it).k2);
	break;
      case _MULT:
	list<double>::iterator it2;
	printf(" , knl={");
	for(it2=(*it).knl.begin();it2!=(*it).knl.end();it2++)
	  printf("5.10g",(*it2));
	printf("},  ksl={");
	for(it2=(*it).ksl.begin();it2!=(*it).ksl.end();it2++)
	  printf("5.10g",(*it2));
	printf("}\n");
	break;

      defaut:
	break;
      }

      printf("\n");

      if((*it).lst != NULL)
	{
	  print(*(*it).lst,++ident);
	  ident--;
	}
    }
}

// ******************************************************
// parser functions
// ******************************************************


int add_func(char *name, double (*func)(double))
{
  struct symtab *sp=symlook(name);
  sp->funcptr=func;
}

int add_var(char *name, double value)
{
  struct symtab *sp=symlook(name);
  sp->value=value;
}



